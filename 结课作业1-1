观察者模式代码实现：
abstract class Subject {  
    private Vector<Observer> obs = new Vector<Observer>();  
  
    public void addObserver(Observer obs){  
       this.obs.add(obs);  
    }  
  
    public void delObserver(Observer obs){  
       this.obs.remove(obs);  
    }  
  
    protected void notifyObserver(){  
       for(Observer o: obs){  
           o.update();  
       }  
    }  
  
    public abstract void doSomething();  
}  
[java] view plain copy print?
class ConcreteSubject extends Subject {  
    public void doSomething(){  
       System.out.println("被观察者事件反生");  
       this.notifyObserver();  
    }  
}  
[java] view plain copy print?
interface Observer {  
    public void update();  
}  
[java] view plain copy print?
class ConcreteObserver1 implements Observer {  
    public void update() {  
       System.out.println("观察者1收到信息，并进行处理。");  
    }  
}  
[java] view plain copy print?
class ConcreteObserver2 implements Observer {  
    public void update() {  
       System.out.println("观察者2收到信息，并进行处理。");  
    }  
}  
[java] view plain copy print?
public class Client {  
    public static void main(String[] args){  
       Subject sub = new ConcreteSubject();  
       sub.addObserver(new ConcreteObserver1()); //添加观察者1  
       sub.addObserver(new ConcreteObserver2()); //添加观察者2  
       sub.doSomething();  
    }  
}  


运行结果：
被观察者事件反生  
观察者1收到信息，并进行处理。  
观察者2收到信息，并进行处理。
